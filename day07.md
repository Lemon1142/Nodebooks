# 面向对象第七天
### call,apply,bind
> 这三个方法都来自Function.prototype，所有函数都可以使用。共同点：可以指定函数执行时内部this的指向。
call和apply的区别在于参数的方式。
bind和前两个方法的区别在于，bind不会马上执行，而是返回一个函数，工供以后调用。

### 补充
- Function.prototype自身是一个函数，并且是唯一一个没有prototype属性的函数。
- call  :  方法，可以改变函数执行时内部this指向
- apply  :  方法，可以改变函数执行时内部this指向
- bind : 方法，返回一个函数的copy版本，并且可以指定该函数执行时内部this的指向
    - 语法：函数名.bind(返回函数执行时的this指向，要绑定的实参1，要绑定的实参2，要绑定的实参3...);
    - 返回值：函数的copy版本

### ES5增了两种严格模式
- 全局模式
- 局部模式

 
```
    //全局模式,即在局代码的最前面添加一句话'use strict'

```

```
   //局部模式，就是在函数代码的最前面写上下面这句话
   function fn() {
    'use strict';
}
```
#### 严格模式的要求：
- 必须通过var定义变量
- 对象中不能存在重复的属性名
- 函数中不能存在重复的形参名
- eval会产生单独的作用域，避免了全局变量的产生。
- 无法在非函数的代码块中声明函数了
- 禁止使用with语句
- 禁止使用函数的caller属性
- 禁止使用arguments的callee属性

### 构造函数的返回值
- 如果函数作为构造器使用，没有return语句，那么忽略，得到实例；
- 如果函数作为构造器使用，return基本数据类型，那么忽略，得到实例；
- 如果函数作为构造器使用，return对象类型的数据，那么覆盖实例，得到return对象。

### setter、getter读写器
- setter、getter是ES5新增的一种语法，市面上称它们为读写器。
```
var a = 1;
var obj = {
    set val ( par ) {
        a = par;
    }, 
    get val () {
        return a;
    }
}
// 对于使用者来说，操作的是obj的val属性，实际上val是两个方法，最终操作的是a变量。
```

### 递归
- 函数自己调用自己，或者间接调用自己，称为递归。

#### 递归的特点
1. 必须要有临界点(临界条件，return语句)
2. 把要解决的问题，尽量细化，如果发现解决问题时用到了之前的成果，并且是有规律的，就可以吧这个规律转化为递归的形式。

### Canvas(画布)
- canvas是用来展示绘制效果的标签，他相当于img标签，用来展示图片.
- getContext可以传两种参数：
    - 1、2d
    - 2、webgl ==> openGl(3D,了解)
- 路径：
    - 路径就是对将来绘制图形轮廓的规划，并不是真正的绘制。
     
       ```
            // 先移动钢笔到指定的位置
            // ctx.moveTo(x, y);
      
            // 画路径的点
            // ctx.lineTo(x, y);

            // 描边路径
            // ctx.stroke();
       ```
#### 设置画布的大小
- 必须通过canvas的属性来设置画布的大小，不能通过css设置，css会拉伸画布
```
    <canvas id="cvs" width="500" height="500"></canvas>
```