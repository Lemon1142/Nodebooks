# 面向对象第四天
### 面向对象三大特征
- 封装，JS中的封装，就是把一堆相关性的变量和函数组织到一起。
- 继承，JS中的继承，就是原型。
- 多态，JS中的多态，可以理解为对象的动态变化。

### for in 语句
- for in用来遍历一个对象可枚举的属性
- 需要注意：该对象继承的属性也能够被遍历出来


### 静态成员与实例成员
1. **静态成员**
    - 静态成员（类成员）：直接添加给类（构造函数）自己的属性和方法，称之为静态成员。
    - 静态成员的**特点**是，不需要创建实例即可通过类调用。
    - **什么情况下会用到静态成员：**
        - 如果一些属性和类的关联性比较大，那么可以考虑作为静态属性存在
        - 如果一些方法具有通用性，那么可以考虑将其作为静态方法存在
2. **实例成员**
    - 添加给实例的属性和方法，称之为实例成员。

### Object.prototype上面的几个方法？
1. **hasOwnProperty**
    - 作用：判断一个对象是否(自己)含有某个属性。
    - 语法: 对象.hasOwnProperty( 要判断的属性名 )。
    - 返回值：boolean
2. **propertyIsEnumerable**
    - 作用：判断一个对象是否(自己)含有某个属性，并且还要判断这个属性是不是可枚举的。
    - 语法: 对象.propertyIsEnumerable( 要判断的属性名 )。
    - 返回值：boolean
3. isPrototypeOf
    - 作用：判断一个对象是不是另一个对象的原型对象.
    - 语法：被判断的对象.isPrototypeOf( 对象 ).
    - 返回值：boolean.
4. toString
    - 作用：根据方法执行时内部的this指向.
    - 返回值：返回一个类似于这样的字符串：'[object this对象的类型名称]'。

### 函数默认的原型对象的类型
- 很多地方认为构造函数默认的显式原型对象的类型，是构造函数的名字。
- 即 Person.prototype 是 Person 类型的对象。

### 函数的几个属性介绍
-1. arguments 
    - 代表实参的伪数组对象，之前arguments是函数的属性，需要通过(函数.arguments使用)。
    - 但是被废除了，arguments已是关键字，可以直接使用，就像this那样
    - caller 返回调用该函数的函数
    - length 形参的个数
    - name 函数的名字
2. 函数的length属性和arguments对象的length属性有什么区别？
    - 函数的length属性用来获取形参的个数
    - arguments对象的length属性用来获取实参的个数
### 运算符
1. in运算符
    - 判断一个对象能否使用某个属性。
    - 语法：'属性名'  in  对象
    - 返回值：boolean
2. delete
    - 作用：删除对象的属性。
    - 语法：delete 对象.属性名

#### 代码块
- 代码块就是一对大括号，里面可以写任意代码；
- 如果想要js把大括号当做对象解析，那么需要把大括号放入表达式中使用。
- 直接使用大括号，就是代码块

### 预解析
- 在代码整体执行之前，先解析一部分。预解析之后，代码才会从上往下依次整体执行，但是预解析执行过的代码不会重复执行。
- js预解析干了什么事
      js中预解析会把声明部分的代码预先执行。
- 声明相关的代码可以分为两部分：

     1、变量声明
     
        通过var关键字定义的变量。
     
     2、函数声明
       通过 function 关键字声明的函数。

#### 变量声明
- 使用var关键字定义的变量，被称为变量声明；
             
             // 其中var a是声明部分。
             var a = 1;
             // 这里的语句整体都是声明部分。
             var b, c, d;
             // 其中var e, f, p是声明部分。
             var e, f = j = 2, p;

- 变量声明提升的特点

      - 在声明变量的前面，可以使用这个变量。

#### 函数声明
1. - **函数声明式定义的特征:**
     + 以function关键字开头定义，
     + 并且定义在全局 或 直接嵌套在另一个函数内，
     + 这种形式定义的函数就是函数声明式。
   - **函数声明式定义的函数其他特征:**
     + 会被预解析
     + 函数必须有名字
     
            // 这是函数声明式
            //function fn() {

              }

            // 外面的是函数表达式
            (function () {
            // 里面的是函数声明式
            function f() {

              }
            })();
     
2. - **函数表达式的特征**
     + 不是以function关键字开头定义的函数；
     + 或者函数嵌套在非函数的代码块中， 都是函数表达式。
   - **函数表达式的其他特征：**
     + 不会被预解析
     + 函数名字可有可无
     + 函数的名字只能在函数内部使用
     
                //var fn = function f() {
                console.log(f); // 函数表达式的名字，只能在里面使用
                };
                n();
                onsole.log(f);  // 函数表达式的名字，在外面无法使用

3. Function 

4. 函数声明提升的特点是，*在函数声明的前面，可以调用这个函数。*

5. 
 -  预解析时如果遇到重复的变量声明，那么忽略。
 - 预解析时如果遇到重复的函数声明，保留后面的函数。
 - 预解析时如果遇到变量与函数重名的情况，保留函数。

6. 关于预解析时重名处理的特点：
    - 凡是遇到重名的变量声明，那么忽略；
    - 凡是遇到重名的函数声明，当前的函数覆盖之前的。

#### 特殊情况的函数表达式 
 > 写在非函数的代码块中，理论上这是函数表达式；
 名字是必须的；
 名字会被预解析；
**浏览器只会预解析它的名字。**

#### 函数执行时形参赋值的顺序（即在预解析之前还是之后）
-  函数执行时内部也存在预解析
- 形参一定是在代码整体执行之前复的值。（预解析之前）

### 作用域
> 就是变量的有效范围。
- **如何检测一个变量的作用域：**
    - 在指定的区域内使用这个变量，如果不报错，说明这个变量的作用域包含此区域。

> 全局变量和局部变量就是通过作用域的大小来对变量进行的种类划分。

#### 函数作用域规则
- 只有函数能够划分变量的作用域，这种作用域的规则就叫函数作用域。
- *在ES6之前，只有函数可以划分变量的作用域，所以在函数的外面无法访问函数内的变量
- 在ES6之前，没有块级作用域的概念，所以在代码块的外面可以访问代码块内的变量*

#### 块级作用域规则
> 凡是代码块就可以划分变量的作用域。


#### 词法作用域(静态作用域)规则
- 如果在函数内访问一个变量，优先找局部变量和形参（在当前执行环境中去找）
- 如果没用找到，去定义该函数的环境中查找（去产生该执行环境的环境中去找），直到全局（全局执行环境）为止。

### 全局变量
- 概念：
    - 在任何地方都可以使用的变量称之为全局变量。
- 定义：
    - 在函数外定义的变量都是全局变量。

### 局部变量
- 概念：
    * 只有指定地方可以使用的变量称之为局部变量。
- 定义：
    * 在函数内声明的变量都是局部变量。
